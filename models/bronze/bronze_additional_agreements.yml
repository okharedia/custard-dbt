version: 2

models:
  - name: bronze_additional_agreements
    description: |
      Raw additional agreements data with basic cleaning applied.
      Parses PostgreSQL interval notation from the 'during' field.
      
      **Interval Notation Support:**
      - `[start, end)` - Includes start, excludes end (standard)
      - `(start, end]` - Excludes start, includes end
      - `(start, end)` - Excludes both
      - `[start, end]` - Includes both
      
      **Note:** Raw data is already in UTC (has +00:00 offset), so no timezone conversion is applied.
    
    columns:
      - name: agreement_id
        description: "Unique identifier for additional agreement"
        tests:
          - unique
          - not_null
      
      - name: from_parent_id
        description: "Parent giving up custody (requesting parent)"
        tests:
          - not_null
          - relationships:
              arguments:
                to: ref('bronze_parents')
                field: parent_id
      
      - name: to_parent_id
        description: "Parent receiving custody (approving parent)"
        tests:
          - not_null
          - relationships:
              arguments:
                to: ref('bronze_parents')
                field: parent_id
      
      - name: during
        description: "Time period for the agreement in PostgreSQL interval notation"
        tests:
          - not_null
      
      - name: start_time
        description: "Parsed agreement start time (UTC)"
        tests:
          - not_null
      
      - name: end_time
        description: "Parsed agreement end time (UTC)"
        tests:
          - not_null
      
      - name: created_at
        description: "Timestamp when record was created"
      
      - name: updated_at
        description: "Timestamp when record was last updated"
      
      - name: _dbt_loaded_at
        description: "Timestamp when dbt loaded this record"
      
      - name: _dbt_layer
        description: "Data layer identifier"
    
    # Model-level unit tests for interval parsing
    tests:
      # Test 1: Verify all parsed timestamps are valid (start < end)
      - dbt_utils.expression_is_true:
          arguments:
            expression: "start_time < end_time"
          config:
            where: "start_time is not null and end_time is not null"
          name: "valid_time_intervals"
      
      # Test 2: Verify no timezone shifts (timestamps should match the +00:00 in raw data)
      # This catches if we accidentally apply timezone conversion
      - dbt_utils.expression_is_true:
          arguments:
            expression: |
              -- Extract hour from raw 'during' string and compare with parsed start_time
              -- Example: '[2025-08-15 00:00:00+00:00,...' should parse to hour 0, not 2
              cast(substring(
                trim(both '[]()' from split_part(during, ',', 1)),
                12, 2
              ) as integer) = extract(hour from start_time)
          config:
            where: "during like '%+00:00%'"
          name: "no_timezone_shift_on_parsing"
      
      # Test 3: Verify interval brackets are parsed correctly
      - dbt_utils.expression_is_true:
          arguments:
            expression: |
              -- Verify we handle all bracket types
              (during like '[%' and during like '%)') or
              (during like '(%' and during like '%]') or  
              (during like '(%' and during like '%)') or
              (during like '[%' and during like '%]')
          name: "valid_interval_notation"
      
      # Test 4: Verify parsed times match raw string content (no corruption)
      - dbt_utils.expression_is_true:
          arguments:
            expression: |
              -- Extract year from raw string and verify it matches parsed timestamp
              cast(substring(
                trim(both '[]()' from split_part(during, ',', 1)),
                1, 4
              ) as integer) = extract(year from start_time)
          name: "parsing_preserves_datetime_values"
    
    # Unit tests with given input and expected output
    # unit_tests:
    #   - name: test_interval_parsing_inclusive_exclusive
    #     description: "Test standard [) format - includes start, excludes end"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-1
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-01-01 00:00:00+00:00,2025-01-02 00:00:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-1
    #           from_parent_id: parent-1
    #           to_parent_id: parent-2
    #           during: "[2025-01-01 00:00:00+00:00,2025-01-02 00:00:00+00:00)"
    #           start_time: "2025-01-01 00:00:00"
    #           end_time: "2025-01-02 00:00:00"
      
    #   - name: test_interval_parsing_exclusive_inclusive
    #     description: "Test (] format - excludes start, includes end"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-2
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "(2025-01-01 00:00:00+00:00,2025-01-02 00:00:00+00:00]"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-2
    #           start_time: "2025-01-01 00:00:00"
    #           end_time: "2025-01-02 00:00:00"
      
    #   - name: test_interval_parsing_both_exclusive
    #     description: "Test () format - excludes both boundaries"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-3
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "(2025-01-01 00:00:00+00:00,2025-01-02 00:00:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-3
    #           start_time: "2025-01-01 00:00:00"
    #           end_time: "2025-01-02 00:00:00"
      
    #   - name: test_interval_parsing_both_inclusive
    #     description: "Test [] format - includes both boundaries"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-4
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-01-01 00:00:00+00:00,2025-01-02 00:00:00+00:00]"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-4
    #           start_time: "2025-01-01 00:00:00"
    #           end_time: "2025-01-02 00:00:00"
      
    #   - name: test_interval_parsing_with_specific_times
    #     description: "Test parsing with specific hour/minute values"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-5
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-06-15 14:30:00+00:00,2025-06-15 18:45:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-5
    #           start_time: "2025-06-15 14:30:00"
    #           end_time: "2025-06-15 18:45:00"
      
    #   - name: test_interval_parsing_multi_day_real_example
    #     description: "Test 7-day transfer (real example from Aug 15-22)"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-6
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-08-15 00:00:00+00:00,2025-08-22 00:00:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-6
    #           start_time: "2025-08-15 00:00:00"
    #           end_time: "2025-08-22 00:00:00"
      
    #   - name: test_interval_parsing_midnight_boundary
    #     description: "Test parsing across midnight/year boundaries"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-7
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-12-31 22:00:00+00:00,2026-01-01 02:00:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-7
    #           start_time: "2025-12-31 22:00:00"
    #           end_time: "2026-01-01 02:00:00"
      
    #   - name: test_no_timezone_shift_on_utc_timestamps
    #     description: "Critical test: Ensure UTC timestamps don't get shifted (the 2-hour bug we fixed!)"
    #     given:
    #       - input: ref('raw_additional_agreements')
    #         rows:
    #           - id: test-uuid-8
    #             from_parent_id: parent-1
    #             to_parent_id: parent-2
    #             during: "[2025-08-15 00:00:00+00:00,2025-08-22 00:00:00+00:00)"
    #             created_at: "2025-01-01 00:00:00"
    #             updated_at: "2025-01-01 00:00:00"
    #     expect:
    #       rows:
    #         - agreement_id: test-uuid-8
    #           # Should parse to 00:00, NOT 02:00!
    #           start_time: "2025-08-15 00:00:00"
    #           end_time: "2025-08-22 00:00:00"
    #           # This would fail if we had the AT TIME ZONE 'UTC' bug:
    #           # start_time: "2025-08-15 02:00:00" ❌ 